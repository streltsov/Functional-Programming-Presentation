<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Shower Presentation Engine</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="shower/themes/ribbon/styles/styles.css" />
    <link rel="stylesheet" href="style.css" />

    <link
      href="https://fonts.googleapis.com/css?family=Inconsolata&display=swap"
      rel="stylesheet"
    />

    <link
      href="https://fonts.googleapis.com/css?family=Charm&display=swap"
      rel="stylesheet"
    />

    <link
      href="https://fonts.googleapis.com/css?family=News+Cycle&display=swap"
      rel="stylesheet"
    />

    <link
      href="https://fonts.googleapis.com/css?family=Alegreya+Sans:100,100i,300,300i,400,400i,500,500i,700,700i,800,800i,900,900i&display=swap&subset=greek"
      rel="stylesheet"
    />
  </head>

  <body class="shower list">
    <header class="caption"><h1>Functional Programming</h1></header>

    <section class="slide flex middle">
      <h2 class="center lambda" style="font-size: 120px">λ</h2>
      <h2 class="big center">Functional Programming</h2>
      <h4 class="center pale">The Failure of State</h4>
    </section>

    <!-- Taking that first step to understanding Functional Programming concepts is the most important and sometimes the most difficult step.
      But it doesn’t have to be. Not with the right perspective. -->
    <!-- Programming is thinking and Functional Programming will teach you to think very differently.
	So much so, that you’ll probably never go back to the old way of thinking. -->
    <!-- There are all kinds of things that you’re used to doing as a programmer that you cannot do any more with Functional Programming. -->
    <!-- Just like in your car, you used to backup to get out of the driveway. But in a spaceship, there is no reverse. Now you may think, “WHAT? NO REVERSE?! HOW THE HELL AM I SUPPOSED TO DRIVE WITHOUT REVERSE?!”
      Well, it turns out that you don’t need reverse in a spaceship because of its ability to maneuver in three dimensional space. Once you understand this, you’ll never miss reverse again. In fact, someday, you’ll think back at how limiting the car really was.-->
    <section class="slide flex middle">
      <img class="center" src="pictures/evolution_of_paradigms.png" alt="" />
    </section>

    <section class="slide flex middle">
      <h2 class="center moderate">Paradigm</h2>
    </section>

    <section class="slide flex middle">
      <p>
        <strong>Паради́гма программи́рования</strong> — это совокупность идей и
        понятий, определяющих стиль написания компьютерных программ <br />
      </p>
    </section>

    <section class="slide flex middle">
      <p>
        <strong>Паради́гма программи́рования</strong> — это способ или подход к
        программированию
      </p>
    </section>

    <!--One very common way people classify languages is to organize them into
      paradigms. You can think of a paradigm as a group of languages that share similar
      characteristics. There are many paradigms currently in use: procedural, functional, and
      object-oriented.  Many of these terms are often misused or confused; there’s also some degree
      of overlap between different paradigms, which definitely doesn’t make things easier.-->

    <!--Существует два основных способа программирования. Первый и по
      историческим причинам самый распространенный, способ при котором программист дает компьютеру
      последовательность инструкций для того чтобы тот вел себя определенным образом.-->

    <section class="slide no-paddings">
      <img src="pictures/programming_paradigms.jpg" />
    </section>

    <section class="slide flex middle">
      <h2 class="center moderate">Imperative programming</h2>
    </section>

    <!--The earliest imperative languages were the machine languages of the
      original computers. In these languages, instructions were very simple, which made hardware
      implementation easier, but hindered the creation of complex programs.-->

    <section class="slide" id="picture">
      <img src="pictures/machine_lang.jpeg" />
    </section>

    <!-- В 1954 году Джон Бакуп из IBM, разработал первый язык высокого уровня,
      который убирал препятствия при создании сложных программ.-->

    <section class="slide flex middle">
      <img class="center" src="pictures/john_backus.jpg" alt="" />
      <h3 class="center">John Warner Backus (1924 - 2007)</h3>
    </section>

    <section class="slide flex middle">
      <img class="center" src="pictures/fortran.jpeg" alt="" />
    </section>

    <section class="slide flex middle">
      <img class="center" src="pictures/algol.jpg" alt="" />
    </section>

    <section class="slide flex middle">
      <img class="center" src="pictures/mumps_lang.jpg" alt="" />
    </section>

    <section class="slide flex middle">
      <img class="center" src="pictures/cobol_lang.jpg" alt="" />
    </section>

    <section class="slide flex middle">
      <img class="center" src="pictures/imperative_langs.png" alt="" />
    </section>

    <section class="slide flex middle">
      <h2 class="center moderate">Imperative programming?</h2>
    </section>

    <section class="slide flex middle">
      <span class="center bold sub-moderate"
        >I really hate this darn machine</span
      >
      <span class="center bold sub-moderate"
        >I wish that they would sell it</span
      >
      <span class="center bold sub-moderate"
        >It won’t do what I want it to,</span
      >
      <span class="center bold sub-moderate">but only what I tell it.</span>
    </section>

    <!--Under the imperative programming paradigm, you program by giving the
      computer orders or commands.  You tell it exactly what it needs to do, how it needs to do it,
      and in what exact order.-->

    <section class="slide flex middle">
      <pre>
        <code class="next">Пройди вперед 2 квартала</code>
	<code class="next">Поверни налево</code>
	<code class="next">Пройди еще три квартала вперед</code>
	<code class="next">Поверни направо</code>
	<code class="next">Найди здание с вывеской "Магазин"</code>
	<code class="next">Войди внутрь</code>
      </pre>
    </section>

    <section class="slide flex middle">
      <p class="center">
        <i>Императи́в</i> (лат. imperativus — повелительный,<br />
        от лат. impero — повелеваю)
      </p>
    </section>

    <section class="slide flex middle">
      <img class="center fit" src="pictures/professor-fortran.png" alt="" />
      <h3 class="center">Энциклопедия профессора Фортрана</h3>
    </section>

    <!--Программное управление. Программа состоит из последовательности машинных
      команд, выбираемых из памяти с помощью счетчика команд. Счетчик — это обычный регистр, он либо
      автоматически увеличивается на единицу по завершении текущей команды, либо его состояние
      меняется принудительно при выполнении команд условного или безусловного переходов.
      Однородность памяти. И программы, и данные хранятся в общей памяти; над кодами команд можно
      выполнять такие же действия, что и над кодами данных.  Следовательно, программу можно
      модифицировать в процессе выполнения, например можно управлять выполнением циклов и
      подпрограмм; программа может быть результатом действия другой программы, на этом основаны
      методы компиляции.  Адресация. Память состоит из перенумерованных ячеек, и процессору в любой
      момент времени доступна любая ячейка.-->

    <!-- This is the style most people learn first: variables, assignments, and
      loops. A problem is solved by dividing its data into small bits (variables) that are updated
      by assignments. Since the data is broken into small bits, the updating is done in stages, by
      repeating assignments over and over: a loop makes repetitions, and each repetition uses the
      same variables to start, perform, and conclude the work.

      Do we do everyday tasks this way? Really, no. This programming paradigm comes from the
      computer hardware --- imperative programming is really all about reading and resetting
      hardware registers. This style of programming arose when hardware people got tired of rewiring
      computer hardware for each and every task --- they developed imperative programming notation
      that represents the wiring diagrams (that is, flow charts --- they are wiring diagrams!). -->

    <!-- In computer science, imperative programming, as contrasted with
      declarative programming, is a programming paradigm that describes computation as statements
      that change a program state. In much the same way as the imperative mood in natural languages
    expresses commands to take action, imperative programs are a sequence of commands for the
    computer to perform.-->

    <!--The hardware implementation of almost all computers is imperative;
      nearly all computer hardware is designed to execute machine code, which is native to the
      computer, written in the imperative style.-->

    <!--Mirrors computer architecture-->
    <!--the imperative paradigm most closely resembles the actual machine
      itself, so the programmer is much closer to the machine; because of such closeness, the
      imperative paradigm was the only one efficient enough for widespread use until recently.-->

    <section class="slide flex middle">
      <img class="center" src="pictures/john_von_neumann.jpg" alt="" />
      <h3 class="center">John von Neumann (1908 - 1957)</h3>
    </section>

    <section class="slide flex middle">
      <h2 class="center sub-big"><i>«Как»</i></h2>
    </section>

    <section class="slide flex middle">
      <h3>1. Triple</h3>
      <pre>
        <code>function triple(array) {</code>
        <code>  let results = []</code>
	<code>  for (let i = 0; i < array.length; i++) {</code>
        <code>    results.push(array[i] * 3)</code>
	<code>  }</code>
	<code>  return results</code>
        <code>}</code>
      </pre>
    </section>

    <section class="slide flex middle">
      <h3>2. Filter by length</h3>
      <pre>
        <code>function filterByLength(array, minLength) {</code>
	<code>  let results = []</code>
	<code>  for (let i = 0; i < array.length; i++) {</code>
	<code>    if (array[i].length > minLength) {</code>
	<code>      results.push(array[i])</code>
	<code>    }</code>
	<code>  }</code>
	<code>  return results</code>
        <code>} </code>
      </pre>
    </section>

    <section class="slide flex middle">
      <h3>3. Multiply</h3>
      <pre>
        <code>function multiply(array) {</code>
	<code>  let results = 1;</code>
	<code>  for (let i = 0; i < array.length; i++) {</code>
        <code>    results = results * array[i];</code>
	<code>  }</code>
	<code>  return results</code>
        <code>}</code>
      </pre>
    </section>
    <!--У ИП пошаговый подход к выполнению задачи. Разработчик разработчик пишет
      комманды которые в точности, от начала до конца описывают как выполнить задачу. Омманды
      исполняются по одной, сверху вниз. По ходу выполнения комманд, изменяется глобальное состояние
      программы в котором записаны её данные. Это наряду с пошаговым выплнением, характерная черта
      ИП: наличие переменных с операцией разрушающего присвоения.-->

    <!--Imperative programming is a paradigm of computer programming in which
      the program describes a sequence of steps that change the state of the computer.-->

    <section class="slide flex middle">
      <h3>Императивное программирование это:</h3>
      <ol>
        <li class="next">Изменяемое состояние</li>
        <li class="next">Последовательное выполнение</li>
      </ol>
    </section>

    <!-- Одной из опор гигантского здания компьютерных технологий являются
	 построения, связанные с именем Джона фон Неймана. Случилось так, что в середине 40-х годов
	 он высказал несколько теоретических положений, не самых существенных в его научной
	 биографии, но именно они обеспечили его имени широкую известность. Но не стоит забывать,
	 что высказаны они были одним человеком, пусть и гениальным, и приняты были в условиях
	 колоссальной неопределенности. В середине 40-х годов не было никакого предшествующего
	 опыта, и, как следствие, в идеях фон Неймана присутствовал заметный элемент случайности и
	 субъективности, что, однако, не помешало последователям со временем канонизировать его
	 теоретические взгляды, придать им статус непогрешимых догм. -->

    <section class="slide flex middle"></section>

    <!-- This is the style most people learn first: variables, assignments, and
      loops. A problem is solved by dividing its data into small bits (variables) that are updated
      by assignments. Since the data is broken into small bits, the updating is done in stages, by
      repeating assignments over and over: a loop makes repetitions, and each repetition uses the
      same variables to start, perform, and conclude the work.

      Do we do everyday tasks this way? Really, no. This programming paradigm comes from the
      computer hardware --- imperative programming is really all about reading and resetting
      hardware registers. This style of programming arose when hardware people got tired of
      rewiring computer hardware for each and every task --- they developed imperative
      programming notation that represents the wiring diagrams (that is, flow charts --- they
      are wiring diagrams!). -->

    <!-- Джон Бэкус — создатель Фортрана и очень известный человек. В 1977 году получил премию Тьюринга в области информатики.
      На вручении награды произнес речь «Можно ли освободить программирование от стиля фон Неймана?». В ней создатель Фортрана —
      обратите внимание — призвал программировать не так, как мы привыкли.-->

    <section class="slide flex middle">
      <img class="center" src="pictures/john_backus_fortran.jpeg" alt="" />
    </section>

    <section class="slide flex middle">
      <img
        class="center"
        src="pictures/can-programming-be-liberated-article.png"
        alt=""
      />
    </section>

    <!-- FP -->
    <!-- Declarative programming is a way of specifying what a program should do, rather than specifying how to do it. -->

    <!-- This statement does not indicate what the SQL system has to do in order to get the data. The SQL system can go through
      each sales record and determine whether the condition is satisfied, or, it can quickly obtain the top few records from
      presorted data. The statement only indicates the nature of the desired data.-->

    <section class="slide flex middle">
      <h2 class="center moderate">Declarative programming</h2>
    </section>

    <section class="slide flex middle">
      <pre>
        <code>Пройди вперед 2 квартала</code>
	<code>Поверни налево</code>
	<code>Пройди еще три квартала вперед</code>
	<code>Поверни направо</code>
	<code>Найди здание с вывеской "Магазин"</code>
	<code>Войди внутрь</code>
      </pre>
    </section>

    <section class="slide flex middle">
      <pre>
	<code>Сходи в магазин</code>
      </pre>
    </section>

    <!-- Достаточно взглянуть на них, чтобы понять, что происходит.
      Они декларативны, заявляя, что должно быть сделано, а не как. Вы описываете желаемый результат, не углубляясь в инструкции
    Неважно, как будут выбраны пользователи из Мексики. Нам важен результат-->
    <section class="slide flex middle">
      <pre>
	<code>SELECT * FROM Users WHERE Country=’Mexico’;</code>
      </pre>
    </section>

    <section class="slide flex middle">
      <img class="center" src="pictures/declarative_html.png" alt="" />
    </section>

    <section class="slide flex middle">
      <h3>1. Triple</h3>
      <pre>
        <code>function triple(array) {</code>
        <code>  let results = []</code>
	<code>  for (let i = 0; i < array.length; i++) {</code>
        <code>    results.push(array[i] * 3)</code>
	<code>  }</code>
	<code>  return results</code>
        <code>}</code>
      </pre>
    </section>

    <section class="slide flex middle">
      <h3>1. Triple</h3>
      <pre>
        <code>function triple(array) {</code>
	<code>  return array.map(el => el * 3)</code>
        <code>}</code>
      </pre>
    </section>

    <section class="slide flex middle">
      <h3>2. Filter by length</h3>
      <pre>
        <code>function filterByLength(array, minLength) {</code>
	<code>  let results = []</code>
	<code>  for (let i = 0; i < array.length; i++) {</code>
	<code>    if (array[i].length > minLength) {</code>
	<code>      results.push(array[i])</code>
	<code>    }</code>
	<code>  }</code>
	<code>  return results</code>
        <code>} </code>
      </pre>
    </section>

    <section class="slide flex middle">
      <h3>2. Filter by length</h3>
      <pre>
        <code>function filterByLength(array, minLength) {</code>
	<code>  return array.filter(el => el.length > minLength)</code>
        <code>}</code>
      </pre>
    </section>

    <section class="slide flex middle">
      <h3>3. Multiply</h3>
      <pre>
        <code>function multiply(array) {</code>
	<code>  let results = 1;</code>
	<code>  for (let i = 0; i < array.length; i++) {</code>
        <code>    results = results * array[i];</code>
	<code>  }</code>
	<code>  return results</code>
        <code>}</code>
      </pre>
    </section>

    <section class="slide flex middle">
      <h3>3. Multiply</h3>
      <pre>
        <code>function multiply(array) {</code>
	<code>  return array.reduce((el, acc) => el * acc)</code>
        <code>}</code>
      </pre>
    </section>

    <section class="slide flex middle">
      <h2 class="center sub-big"><i>«Что»</i></h2>
    </section>

    <section class="slide flex middle">
      <h2 class="center moderate">Functional Programming</h2>
    </section>

    <!-- В 30-х годах прошлого века, немецкий математик Дэвид Гилберт сформулировал так называемую "Проблему разрешения" -->
    <section class="slide flex middle">
      <img class="center fit" src="pictures/david_hilbert.jpg" alt="" />
      <h3 class="center">David Hilbert (1862–1943)</h3>
    </section>

    <!-- Суть её в том, что вот есть у нас некий формальный язык, на котором можно написать какое-либо утверждение.
      Существует ли алгоритм, за конечное число шагов определяющий его истинность или ложность? -->
    <section class="slide flex middle">
      <h3 class="center moderate bold">Entscheidungsproblem</h3>
    </section>

    <!--Ответ был найден великим учёными того времени Аланом Тьюрингом. -->
    <section class="slide flex middle">
      <img class="center fit" src="pictures/alan_turing.jpg" alt="" />
      <h3 class="center">Alan Turing (1912–1954)</h3>
    </section>

    <!-- С помощью абстрактной вычислительной машины (машины Тьюринга),
	он показал, что для арифметики такого алгоритма не существует в принципе, т.е. Entscheidungsproblem в общем случае неразрешима. -->
    <section class="slide flex middle">
      <img class="center fit" src="pictures/turing_machine.jpg" alt="" />
      <h3 class="center">An implementation of a Turing machine</h3>
    </section>

    <section class="slide flex middle">
      <img class="center fit" src="pictures/alonzo_church.jpg" alt="" />
      <h3 class="center">Alonzo Church (1903–1995)</h3>
    </section>

    <!-- Lambda calculus is important in programming language theory, and the symbol λ has even been adopted as an unofficial symbol for the field.
      It can be considered the smallest universal programming language: any computable function can be evaluated in the context of λ-calculus and
      evaluating programs in the language consists of a single transformation rule: variable substitution. -->
    <!-- Так лямбда-исчисление впервые громко заявило о себе, но ещё пару десятков лет продолжало быть достоянием математической логики.-->
    <section class="slide flex middle">
      <img class="center" src="pictures/scary_lambda_calculus.png" alt="" />
      <h3 class="center">Lambda Calculus</h3>
    </section>

    <section class="slide flex middle">
      <figure>
        <blockquote>
          <p class="center">
            Возможно, у этой системы найдутся приложения не только в роли
            логического исчисления.
          </p>
        </blockquote>
        <figcaption>
          Алонзо Чёрч, 1932
        </figcaption>
      </figure>
    </section>

    <section class="slide flex middle">
      <img class="center" src="pictures/john_mccarthy.jpeg" alt="" />
      <h3 class="center">John McCarthy (1927 - 2011)</h3>
    </section>

    <section class="slide flex middle">
      <span class="center moderate">M==0 ? N1 : N2</span>
    </section>

    <!-- McCarthy in the late 1950s defined the first versions of LISP, which uses Church's λ notation for functions.  Interestingly, by McCarthy's own account(1978), Lambda Calculus had little impact on the development of LISP other than the lambda notation.  -->
    <!--  Nevertheless, LISP had many innovations which was influential on both theorectic and practical aspects of functional programming:

    The use of garbage collection as a method of claiming unused cells (a funny story about the demonstration of the earlist garbage collector; see the appendix section).
    Use closures to implement static scoping. For example, in "let x = 3 in f = λ y. x + y", function f is not closed since it has a free variable x. To use f, it has to be bound with an environment that tells the value of x. A function with the environment for its free variables is called a closure.
    Invention of the conditional expression and its use for writing recursive functions. This has something to do with the evaluation order of expressions(see lazy evaluation).
    Use higher-order operations on list such as the mapcar function. we will have say more about higher-order functions.
    -->
    <!--Lisp was originally created as a practical mathematical notation for computer programs, influenced by the notation of Alonzo Church's lambda calculus. It quickly became the favored programming language for artificial intelligence (AI) research.-->
    <section class="slide flex middle">
      <img class="center" src="pictures/lisp-logo.png" alt="" />
      <h3 class="center">LISP (1958)</h3>
    </section>

    <!--The MIT Lisp machine of the 60s and 70s was an attempt to implement
      functional programming at the hardware level, but it never really became a commercially viable
      mainstream product. Approximately 7000 Lisp machines were built by a handful of companies.-->
    <section class="slide flex middle">
      <img class="center" src="pictures/mit-lisp-machine.jpg" alt="" />
      <h3 class="center">MIT Lisp machine</h3>
    </section>

    <!--  в середине 60-х Питер Ландин не отметил, что сложный язык программирования проще изучать, сформулировав его ядро в виде небольшого базового исчисления, выражающего самые существенные механизмы языка и дополненного набором удобных производных форм, поведение которых можно выразить путем перевода на язык базового исчисления. В качестве такой основы Ландин использовал лямбда-исчисление Чёрча. И всё заверте…-->
    <section class="slide flex middle">
      <img class="center" src="pictures/peter_landin.png" alt="" />
      <h3 class="center">Peter Landin (1930 - 2009)</h3>
    </section>

    <section class="slide flex middle">
      <img class="center" src="pictures/david_turner.jpg" alt="" />
      <h3 class="center">David Turner (1946)</h3>
    </section>

    <!--  (1972) -->
    <section class="slide flex middle">
      <h3 class="center moderate bold">SASL</h3>
    </section>

    <!-- Although not implemented, it has proved very influential in the development of programming languages, especially functional programming languages -->
    <!-- ISWIM is an imperative language with a functional core, consisting of a syntactic sugaring of lambda calculus to which are added mutable variables and assignment and a powerful control mechanism: the "program point" operator. Being based on lambda calculus ISWIM has higher order functions and lexically scoped variables.-->
    <section class="slide flex middle">
      <h3 class="center moderate bold">ISWIM</h3>
    </section>

    <!--  The language was widely taken up, both for research and for teaching, and had a strong influence on the subsequent development of the field, influencing in particular the design of Haskell, to which it has many similarities. -->
    <section class="slide flex middle">
      <img class="center" src="pictures/miranda_logo.jpg" alt="" />
      <h3 class="center">Miranda (1983)</h3>
    </section>

    <section class="slide flex middle">
      <img class="center" src="pictures/evolution_of_fpl.jpg" alt="" />
      <h3 class="center">"Evolution" of FP languages</h3>
    </section>

    <section class="slide flex middle">
      <img class="center" src="pictures/evolution_tree.jpg" alt="" />
      <h3 class="center">Tree of Evolution</h3>
    </section>

    <!-- Following the release of Miranda by Research Software Ltd. in 1985, interest in lazy functional languages grew. By 1987, more than a dozen non-strict, purely functional programming languages existed. Miranda was the most widely used, but it was proprietary software. At the conference on Functional Programming Languages and Computer Architecture (FPCA '87) in Portland, Oregon, there was a strong consensus that a committee be formed to define an open standard for such languages. The committee's purpose was to consolidate existing functional languages into a common one to serve as a basis for future research in functional-language design.-->
    <!-- Миранда был первым чистым функциональным языком, имевшим коммерческую поддержку, и был относительно популярен в 1980-х годах, но оставался собственническим программным обеспечением. Это затрудняло развитие и исследования возможностей ленивого функционального программирования, поэтому буквально за пару лет появилось более десятка схожих языков. Чтобы объединить усилия разных разработчиков в 1987 году на конференции по функциональным языкам программирования и компьютерной архитектуре в Орегоне (FPCA’87) было решено создать комитет для разработки открытого стандарта. -->
    <section class="slide flex middle">
      <img class="center" src="pictures/evolution_of_fpl.jpg" alt="" />
      <h3 class="center">"Evolution" of FP languages</h3>
    </section>

    <!-- Собрался специальный комитет из отборнейших задротов и без лишнего шума создали его.-->
    <section class="slide flex middle">
      <img class="center" src="pictures/committee.jpg" alt="" />
    </section>

    <!-- Haskell — функциональный декларативный язык программирования, первая версия которого была стандартизирована в 1990 году, назван в честь математика Хаскелла Карри. Язык Haskell известен благодаря синтаксису, в сравнении с которым пёрл выглядит псевдокодом, а также необходимостью глубокого понимания лямбда-исчисления, замыканий, теории графов, теории категорий, сопромата, анатомии мозга и прочего матана даже для вывода на экран строки «Hello, World!» -->
    <section class="slide flex middle white">
      <img class="center" src="pictures/haskell_logo.svg" alt="" />
    </section>

    <section class="slide flex middle">
      <img class="center" src="pictures/haskell_hello_world.jpg" alt="" />
    </section>

    <section class="slide flex middle">
      <pre>
        <code>main :: IO ()</code>
        <code>main = putStrLn "Hello, world!"</code>
      </pre>
    </section>

    <!-- В 1990 году была предложена первая версия языка, Haskell 1.0. -->
    <!-- Отличительная черта языка — серьёзное отношение к типизации; во многом в связи с этим язык назван в честь исследователя теории типов и изобретателя комбинаторной логики Хаскелла Карри. -->
    <section class="slide flex middle white">
      <img class="center" src="pictures/haskell_logo.svg" alt="" />
    </section>

    <section class="slide flex middle haskell">
      <ol>
        <li class="next">Чистота языка</li>
        <li class="next">Иммутабельность</li>
        <li class="next">Функции высшего порядка</li>
        <li class="next">Частичное применение</li>
        <li class="next">Статическая сильная полная типизация</li>
        <li class="next">Ленивые вычисления</li>
        <li class="next">Алгебраические типы данных</li>
        <li class="next">Параметрический полиморфизм</li>
        <li class="next">Параметрический полиморфизм высших рангов</li>
        <li class="next">...</li>
      </ol>
    </section>

    <section class="slide flex middle">
      <h2 class="center moderate">Lambda Calculus</h2>
    </section>

    <section class="slide flex middle">
      <p class="lambda center moderate">λf.(λx.(f(xx)) λx.(f(xx)))</p>
    </section>

    <section class="slide flex middle">
      <p class="lambda center big">λx.x</p>
    </section>

    <section class="slide flex middle">
      <p class="lambda center big"><span class="glow">λ</span>x.x</p>
    </section>

    <section class="slide flex middle">
      <p class="lambda center big">λ<span class="glow">x</span>.x</p>
    </section>

    <section class="slide flex middle">
      <p class="lambda center big">λx<span class="glow">.</span>x</p>
    </section>

    <section class="slide flex middle">
      <p class="lambda center big">λx.<span class="glow">x</span></p>
    </section>

    <section class="slide flex middle">
      <p class="lambda center big">λx.x</p>
      <p class="js center moderate">x => x</p>
    </section>

    <section class="slide flex middle ">
      <pre class="sub-moderate">
        <code>x => x</code>
	<code> </code>
	<code>function(x) {</code>
	<code> return x;</code>
        <code>}</code>
      </pre>
    </section>

    <section class="slide flex middle">
      <p class="lambda center big">λx.x</p>
      <p
        class="js center
    moderate"
      >
        x => x
      </p>
    </section>

    <section class="slide flex middle">
      <h2 class="center moderate">Pure Functions</h2>
    </section>

    <section class="slide flex middle ">
      <pre>
      <code>let limit = 5;</code>
      <code>let state = ['Some', 'properties', 'already', 'exists'];</code>
      <code>let flag = true;</code>
      <code>function changeState(object) {</code>
      <code>  for(let property in object) {</code>
      <code>    if(property.length < limit && flag == true) {</code>
      <code>      state.push(property);</code>
      <code>    }</code>
      <code>  }</code>
      <code>  flag = !flag;</code>
      <code>}</code>
      </pre>
    </section>

    <section class="slide flex middle">
      <h2 class="center big red">return</h2>
    </section>

    <section class="slide flex middle ">
      <pre>
      <code>function changeState(object) {</code>
      <code>  for(let property in object) {</code>
      <code>    if(property.length < limit && flag == true) {</code>
      <code>      state.push(property);</code>
      <code>    }</code>
      <code>  }</code>
      <code>  flag = !flag;</code>
      <code>  return object;</code>
      <code>}</code>
      </pre>
    </section>

    <section class="slide">
      <h2>Чистая функция:</h2>
      <ol>
        <li class="next">Принимает аргумент(ы)</li>
        <li class="next">Не имеет побочных эффектов</li>
        <li class="next">Возвращает значение</li>
      </ol>
    </section>

    <!--In computer science, an operation, function or expression is said to have a side effect
      if it modifies some state variable value(s) outside its local environment,
      that is to say has an observable effect besides returning a value (the main effect)-->
    <!-- Изменение внешнего состояния, запись в базу, запросы к серверу, операции ввода вывода и т.д. -->

    <section class="slide flex middle ">
      <pre class="sub-moderate">
        <code>function max(first, second) {</code>
	<code>  if(first > second) {</code>
        <code>    return first;</code>
	<code>  } else {</code>
        <code>    return second;</code>
        <code>}</code>
      </pre>
    </section>

    <section class="slide flex middle ">
      <pre class="sub-moderate">
        <code>function isInThePast(day) {</code>
	<code>  return new Date().getDate() < day</code>
        <code>}</code>
      </pre>
    </section>

    <section class="slide flex middle ">
      <pre class="sub-moderate">
        <code>function isBiggerThanFive(number) {</code>
	<code>  return number > 5</code>
        <code>}</code>
      </pre>
    </section>

    <section class="slide flex middle ">
      <pre class="sub-moderate">
      <code>function addProperty(object) {</code>
      <code>  object.theAnswer = 42;</code>
      <code>  return object;</code>
      <code>}</code>
      </pre>
    </section>

    <section class="slide flex middle ">
      <pre>
      <code>let limit = 5;</code>
      <code>let state = ['Some', 'properties', 'already', 'exists'];</code>
      <code>let flag = true;</code>
      <code>function changeState(object) {</code>
      <code>  for(let property in object) {</code>
      <code>    if(property.length < limit && flag == true) {</code>
      <code>      state.push(property);</code>
      <code>    }</code>
      <code>  }</code>
      <code>  flag = !flag;</code>
      <code>}</code>
      </pre>
    </section>

    <section class="slide flex middle ">
      <pre>
      <code>function changeState(object, state, limit, flag) {</code>
      <code>  for(let property in object) {</code>
      <code>    if(property.length < limit && flag == true) {</code>
      <code>      state.push(property);</code>
      <code>    }</code>
      <code>  }</code>
      <code>  return state;</code>
      <code>}</code>
      </pre>
    </section>

    <section class="slide flex middle ">
      <pre>
      <code>function createNewState(object, state, limit, flag) {</code>
      <code>  const filtered = flag</code>
      <code>    ? Object.keys(object).filter(key => key.length < limit)</code>
      <code>    : []</code>
      <code>  return [...state, ...filtered]</code>
      <code>}</code>
      </pre>
    </section>

    <section class="slide flex middle">
      <h2 class="center moderate">Immutability</h2>
    </section>

    <section class="slide flex middle">
      <img class="center fit" src="pictures/immutable_x.jpg" alt="" />
    </section>

    <!-- Do you remember when you first saw the following bit of code:-->
    <!--And whoever was teaching you told you to forget what you learned in math class? In math, x can never be equal to x + 1.
      But in Imperative Programming, it means, take the current value of x add 1 to it and put that result back into x.
      Well, in functional programming, x = x + 1 is illegal. So you have to remember what you forgot in math… Sort of.-->
    <!-- присваевание не равно сравнение -->
    <section class="slide flex middle">
      <pre class="sub-moderate">
        <code>let x = 1;</code>
        <code>x = x + 1</code>
      </pre>
    </section>

    <!--Stored values are still called variables because of history but they are constants,
      i.e. once x takes on a value, it’s that value for life.-->
    <section class="slide flex middle forbidden">
      <pre class="sub-moderate">
        <code>let x = 1;</code>
        <code>x = x + 1</code>
      </pre>
    </section>

    <section class="slide flex">
      <pre class="sub-moderate">
        <code>let numbers = [4, 8, 15, 16, 23, 42];</code>
      </pre>
    </section>

    <section class="slide flex">
      <pre class="sub-moderate">
        <code>let numbers = [4, 8, 15, 16, 23, 42];</code>
	<code>numbers.push(108);</code>
      </pre>
    </section>

    <section class="slide flex">
      <pre class="sub-moderate">
        <code>let numbers = [4, 8, 15, 16, 23, 42];</code>
	<code><strike>numbers.push(108);</strike></code>
      </pre>
    </section>

    <section class="slide flex">
      <pre class="sub-moderate">
        <code>let numbers = [4, 8, 15, 16, 23, 42];</code>
	<code><strike>numbers.push(108);</strike></code>
        <code>numbers[2] = 20;</code>
      </pre>
    </section>

    <section class="slide flex">
      <pre class="sub-moderate">
        <code>let numbers = [4, 8, 15, 16, 23, 42];</code>
	<code><strike>numbers.push(108);</strike></code>
	<code><strike>numbers[2] = 20;</strike></code>
      </pre>
    </section>

    <section class="slide flex">
      <pre class="sub-moderate">
        <code>let numbers = [4, 8, 15, 16, 23, 42];</code>
	<code><strike>numbers.push(108);</strike></code>
	<code><strike>numbers[2] = 20;</strike></code>
	<code>numbers.pop();</code>
      </pre>
    </section>

    <section class="slide flex">
      <pre class="sub-moderate">
        <code>let numbers = [4, 8, 15, 16, 23, 42];</code>
	<code><strike>numbers.push(108);</strike></code>
	<code><strike>numbers[2] = 20;</strike></code>
	<code><strike>numbers.pop();</strike></code>
      </pre>
    </section>

    <section class="slide flex">
      <pre class="sub-moderate">
        <code>let numbers = [4, 8, 15, 16, 23, 42];</code>
	<code><strike>numbers.push(108);</strike></code>
	<code><strike>numbers[2] = 20;</strike></code>
	<code><strike>numbers.pop();</strike></code>
	<code>numbers.unshift();</code>
      </pre>
    </section>

    <section class="slide flex">
      <pre class="sub-moderate">
        <code>let numbers = [4, 8, 15, 16, 23, 42];</code>
	<code><strike>numbers.push(108);</strike></code>
	<code><strike>numbers[2] = 20;</strike></code>
	<code><strike>numbers.pop();</strike></code>
	<code><strike>numbers.unshift();</strike></code>
      </pre>
    </section>

    <section class="slide flex">
      <pre class="sub-moderate">
        <code>let numbers = [4, 8, 15, 16, 23, 42];</code>
	<code><strike>numbers.push(108);</strike></code>
	<code><strike>numbers[2] = 20;</strike></code>
	<code><strike>numbers.pop();</strike></code>
	<code><strike>numbers.unshift();</strike></code>
	<code>numbers.shift(1);</code>
      </pre>
    </section>

    <section class="slide flex">
      <pre class="sub-moderate">
        <code>let numbers = [4, 8, 15, 16, 23, 42];</code>
	<code><strike>numbers.push(108);</strike></code>
	<code><strike>numbers[2] = 20;</strike></code>
	<code><strike>numbers.pop();</strike></code>
	<code><strike>numbers.unshift();</strike></code>
	<code><strike>numbers.shift(1);</strike></code>
	<code>numbers.splice(0, 0, 1);</code>
      </pre>
    </section>

    <section class="slide flex">
      <pre class="sub-moderate">
        <code>let numbers = [4, 8, 15, 16, 23, 42];</code>
	<code><strike>numbers.push(108);</strike></code>
	<code><strike>numbers[2] = 20;</strike></code>
	<code><strike>numbers.pop();</strike></code>
	<code><strike>numbers.unshift();</strike></code>
	<code><strike>numbers.shift(1);</strike></code>
	<code><strike>numbers.splice(0, 0, 1);</strike></code>
      </pre>
    </section>

    <section class="slide flex middle">
      <ol class="sub-moderate">
        <li class="next">Какие преимущества у иммутабельности?</li>
        <li class="next">Как программировать без переменных?</li>
      </ol>
    </section>

    <section class="slide flex middle">
      <h3>Features of Immutability</h3>
      <ol class="sub-moderate">
        <li class="next">Easiness to reason about</li>
        <li class="next">Mutithreading</li>
      </ol>
    </section>

    <section class="slide flex middle">
      <pre class="sub-moderate">
        <code>let numbers = [4, 8, 15, 16, 23, 42];</code>
      </pre>
    </section>

    <section class="slide flex middle">
      <pre class="sub-moderate">
        <code>let numbers = [4, 8, 15, 16, 23, 42];</code>
        <code>let newNumbers = [...numbers, 108];</code>
      </pre>
    </section>

    <section class="slide flex middle">
      <pre class="sub-moderate">
        <code>let numbers = [4, 8, 15, 16, 23, 42];</code>
        <code>let newNumbers = numbers.slice(1);</code>
      </pre>
    </section>

    <section class="slide flex middle">
      <pre class="sub-moderate">
        <code>let numbers = [4, 8, 15, 16, 23, 42];</code>
        <code>let newNumbers = numbers.slice(0, numbers.length - 1);</code>
      </pre>
    </section>

    <section class="slide flex middle">
      <pre class="sub-moderate">
        <code>let numbers = [4, 8, 15, 16, 23, 42];</code>
        <code>let newNumbers = tail numbers;</code>
      </pre>
    </section>

    <section class="slide flex middle">
      <pre class="sub-moderate">
        <code>let numbers = [4, 8, 15, 16, 23, 42];</code>
        <code>let newNumbers = init numbers;</code>
      </pre>
    </section>

    <section class="slide flex middle">
      <pre class="sub-moderate">
        <code>let numbers = [4, 8, 15, 16, 23, 42];</code>
        <code>let newNumbers = numbers ++ [108];</code>
      </pre>
    </section>

    <section class="slide flex middle">
      <h2 class="center moderate">
        <i>Immutability creates simpler and safer code.</i>
      </h2>
    </section>

    <section class="slide">
      <h2>Чего в FP нет:</h2>
      <ol>
        <li class="next">Переменных</li>
        <li class="next">Циклов</li>
        <li class="next">Ветвлений</li>
      </ol>
    </section>

    <section class="slide">
      <h2>Что в FP есть:</h2>
      <ol>
        <li class="next">Чистые функции</li>
        <li class="next">Иммутабельность</li>
        <li class="next">Каррирование</li>
        <li class="next">Композиция функций</li>
        <li class="next">Функции первого класса</li>
        <li class="next">Функции высшего порядка</li>
        <li class="next">Рекурсия</li>
        <li class="next">Замыкания</li>
      </ol>
    </section>

    <section class="slide">
      <h3>Функциональные языки програмирования</h3>
      <img
        src="pictures/idris-logo.png"
        width="227px"
        style="margin-right: 240px"
      />
      <img src="pictures/mercury-logo.png" width="327px" />
      <img
        src="pictures/haskell-logo.svg"
        width="420px"
        style="display: block; margin: 20px
	     140px"
      />
      <img
        src="pictures/purescript-logo.svg"
        width="220px"
        style="background-color: black"
      />
      <img src="pictures/miranda-logo.jpg" width="527px" />
    </section>

    <section class="slide">
      <pre style="font-size: 17px"> <code>bool flag;</code> <code>int f (int
    n) {</code> <code>    int retVal;</code> <code>    if flag then retVal = 2 * n;</code> <code>
    else retVal = n;</code> <code>    flag = ! flag;</code> <code>    return retVal;</code>
    <code>}</code> <code> </code> <code>void test() {</code> <code>    flag = true;</code> <code>
    print ( "f(1) + f(2) = %d/n", f(1) + f(2) );</code> <code>    print ( "f(2) + f(1) = %d/n", f(2)
      + f(1) );</code> <code>}</code> </pre>
    </section>

    <section class="slide">
      <img src="pictures/ocaml-logo.png" width="220px" />
      <h2>Shower key features</h2>
      <ol>
        <li>Built on HTML, CSS and JavaScript</li>
        <li>Works in all modern browsers</li>
        <li>Themes are separated from engine</li>
        <li>Fully keyboard accessible</li>
        <li>Printable to PDF</li>
      </ol>
      <p class="note">Shower ['ʃəuə] noun. A person or thing that shows.</p>
    </section>

    <section class="slide">
      <h2>Plain text on your slides</h2>
      <p>
        Lorem ipsum dolor sit amet, consectetur
        <a href="#4">adipisicing</a> elit, sed do eiusmod tempor incididunt ut
        labore et dolore magna aliqua. Ut enim ad minim veniam,
        <em>quis nostrud</em> exercitation ullamco laboris
        <strong>nisi ut aliquip</strong> ex ea commodo consequat. Duis aute
        irure <i>dolor</i> in reprehenderit in voluptate velit esse cillum
        <b>dolore</b> eu fugiat nulla pariatur. Excepteur sint occaecat
        cupidatat non proident, sunt in <code>&lt;culpa&gt;</code> qui officia
        deserunt mollit anim id est laborum.
      </p>
    </section>

    <section class="slide">
      <h2>All kind of lists</h2>
      <ol>
        <li>Simple lists are marked with bullets</li>
        <li>Ordered lists begin with a number</li>
        <li>
          You can even nest lists one inside another
          <ul>
            <li>Or mix their types</li>
            <li>But do not go too far</li>
            <li>Otherwise audience will be bored</li>
          </ul>
        </li>
        <li>Look, seven rows exactly!</li>
      </ol>
    </section>

    <section class="slide">
      <h2>Serious citations</h2>
      <figure>
        <blockquote>
          <p>Life is to short for imperative programming</p>
        </blockquote>
        <figcaption>Marcus Tullius Cicero</figcaption>
      </figure>
    </section>

    <section class="slide">
      <h2>Code samples</h2>
      <pre> <code>&lt;!DOCTYPE html&gt;</code> <code
	     class="mark">&lt;html lang="en"&gt;</code> <code><mark>&lt;head&gt;</mark> <span
			    class="comment">&lt;!--Comment--&gt;</span></code> <code>
			    &lt;title&gt;Shower&lt;/title&gt;</code> <code>    &lt;meta
			    charset="<mark class="important">UTF-8</mark>"&gt;</code> <code>
			    &lt;link rel="stylesheet" href="screen.css"&gt;</code>
      <code><mark>&lt;/head&gt;</mark></code> </pre>
    </section>

    <section class="slide">
      <h2>Even tables</h2>
      <table>
        <tr>
          <th scope="col">Locavore</th>
          <th>Umami</th>
          <th>Helvetica</th>
          <th>Vegan</th>
        </tr>
        <tr>
          <th scope="row">Fingerstache</th>
          <td>Kale</td>
          <td>Chips</td>
          <td>Keytar</td>
        </tr>
        <tr>
          <th scope="row">Sriracha</th>
          <td>Gluten-free</td>
          <td>Ennui</td>
          <td>Keffiyeh</td>
        </tr>
        <tr>
          <th scope="row">Thundercats</th>
          <td>Jean</td>
          <td>Shorts</td>
          <td>Biodiesel</td>
        </tr>
        <tr>
          <th scope="row">Terry</th>
          <td>Richardson</td>
          <td>Swag</td>
          <td>Blog</td>
        </tr>
      </table>

      <p>It’s good to have information organized.</p>
    </section>

    <section class="slide">
      <h2 class="shout shrink">You can even shout this way</h2>
    </section>

    <section class="slide">
      <h2>Inner navigation</h2>
      <ol>
        <li>Lets you reveal list items one by one</li>
        <li class="next">To keep some key points</li>
        <li class="next">In secret from audience</li>
        <li class="next">But it will work only once</li>
        <li class="next">Nobody wants to see the same joke twice</li>
      </ol>
    </section>

    <section class="slide" id="see-more">
      <h2 class="shout">
        <img src="pictures/logo.svg" alt="Shower logo" />
        <a href="https://github.com/shower/shower">See more on GitHub</a>
      </h2>
      <style>
        #see-more h2 {
          font-size: 100px;
        }

        #see-more img {
          width: 0.72em;
          height: 0.72em;
        }
      </style>
    </section>

    <footer class="badge">
      <a href="https://github.com/shower/shower">Fork me on GitHub</a>
    </footer>

    <div class="progress"></div>

    <script src="shower/shower.min.js"></script>
    <!-- Copyright © 3000 Yours Truly, Famous Inc. -->
  </body>
</html>
